---
layout: post
comments: false
title: "Python"
date: 2021-12-30 01:09:00


---
<!--more-->

{: class="table-of-content"}
* TOC
{:toc}
---

<!--more-->

python的参考资料：

1. [python的官方文档](https://docs.python.org/3/index.html)
包括了tutorial（大致介绍了基本的python语法）、标准库、language reference（也就是详尽的从头到尾的python语法介绍）、C/CPP和python的接口文档手册等等。
2. [Python的标准库](https://docs.python.org/3/library/index.html)
介绍了Python自带的built-in functions，built-in types，built-in exceptions和各种modules
3. [Numpy的官方文档](https://numpy.org/doc/stable/index.html)
包括了基本的user guide（大致介绍了基本用法）、API（完整的内容介绍）、developer guide（给想开发的人的指南）。
4. [Pandas库的官方文档](https://pandas.pydata.org/docs/)
包括了基本的user guide（大致介绍了基本用法）、API（完整的内容介绍）、developer guide（给想开发的人的指南）。
5. [Matplotlib库的官方文档](https://matplotlib.org/stable/index.html)
6. [Scikit-learn库的官方文档](https://scikit-learn.org/stable/index.html)

本post不会重复参考资料里的内容，但可能会对其进行补充。本post主要会对重要的python内容进行介绍，比如说一些库（有的来自于标准库比如argparse，有的来自于著民第三方库，比如Numpy，但重要的库，比如说pytorch，还是会另开post来介绍），其中可能会综合汇总其他人博客里的内容（会标明出处），以达到对python常用内容可以迅速复习的目的。


## Python里的描述符

描述符的定义很简单，实现了下列任意一个方法的`python`对象就是一个描述符（descriptor）：

* `__get__(self, obj, type=None)`
* `__set__(self, obj, value)`
* `__delete__(self, obj)`

这些方法的参数含义如下：`self`是当前定义的描述符对象实例。`obj`是该描述符将作用的对象实例。`type`是该描述符作用的对象的类型（即所属的类）。

上述对描述符的定义方式也被称为描述符协议，`python`会在特定的时机按协议传入参数调用某一方法，如果我们未按协议约定的参数定义方法，调用可能会出错。

> 之所以称为描述符协议，是因为这只是个约定俗成的定义，并没有语法来约束它。

描述符可以用来控制对属性的访问行为，实现计算属性、懒加载属性、属性访问控制等功能，我们先来举个简单的例子：

```python
class Descriptor:

    def __get__(self, instance, owner):
        if instance is None:
            print('__get__(): Accessing x from the class', owner)
            return self
        
        print('__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Foo:
    x = Descriptor()
```

## 2. Python的metaclass

https://segmentfault.com/a/1190000007255412

## decorator和descriptor

https://www.jianshu.com/p/cc1e8a18b708

## Python里的super函数

参考文献
* https://fuhm.org/super-harmful/
* https://rhettinger.wordpress.com/2011/05/26/super-considered-super/
* https://xiehongfeng100.github.io/2016/12/03/python-basics-mro/
* https://www.cnblogs.com/marsggbo/p/14526714.html
* https://zhuanlan.zhihu.com/p/356720970
* https://laike9m.com/blog/li-jie-python-super,70/
* https://blog.csdn.net/wo198711203217/article/details/84097274


https://blog.csdn.net/wo198711203217/article/details/84097274

## Python常见I/O文件格式

### 1. Python读取.npy和.npz文件

`npy`以及`npz`这两种文件格式，是`python`第三方库`numpy`才能够保存和读取的文件类型。

对于`npy`文件只需要将`numpy`这个第三方库导入进来，然后调用方法生成数组或者矩阵对象。再使用`save()`方法并传入文件保存路径以及数据对象，就可以将其保存为`npy`文件，代码如下：

```python
import numpy as np
data_1 = np.zeros((3, 3))
np.save("test.npy", data_1)
```

唯一需要注意这个文件必须是以`npy`作为后缀名的，而读取文件就更加简单了，调用`load()`方法并传入文件路径就可以直接把`npy`文件数据给读取出来。

`npz`文件是以字典形式来保存数据的，它会给传进来的每一个数组分配一个单独存在不重复的字典键。只需要在`save`后面加上一个字母`z`就能够将其保存为`npz`文件，其余的语法和上面示例中是一样的，代码如下：

```python
import numpy as np
data_1 = np.zeros((3, 3))
np.savez("test.npz", data_1)
```

不过读取`npz`文件的方法就有点不同了，它需要先将其调用`load()`方法把数据都给取出来。然后再通过循环迭代字典键的方式才可以得到具体对应的数据，代码示例如下所示：

```python
datas = np.load("test.npz")
#第一种方法
print(datas.files)  #['arr_0']
print(datas['arr_0'])
#第二种方法
for key, arr in datas.items():
  print(key, ": ", arr)
```

### 2. 使用pickle存储读取字典

对于字典类型数据，`python`最常用的是`pickle`包来读取和存储，如下是利用`pickle`来存储字典和读取字典的例子

```python
import pickle
 
a_dict = {'da': 111, 2: [23,1,4], '23': {1:2,'d':'sad'}}
 
# pickle a variable to a file
with open('pickle_example.pickle', 'wb') as f:
    pickle.dump(a_dict, file)

with open('pickle_example.pickle', 'rb') as file:
    a_dict1 =pickle.load(file)

## a_dict1文件就直接是一个字典
```

## python -c 命令与python -m 命令的用法

`python`的`-c`可以直接在命令行中调用`python`代码, 实际上`-c`就是command的意思。简言之就是`python -c`可以在命令行中执行`python`代码, 跟把代码放置在`.py`文件中，然后运行这个文件是一样的效果。

```shell
python -c "print('TYXC')"  ## 注意，如果括号里面也用双引号的话会报错。
python -c "print("TYXC")"  ## 报错
python -c '''print("TYXC")''' ##正常执行

## 这样还有一个好处就是也可以执行多行的代码：
python -c '''
import arrow    
print(arrow.now())
'''
```

`python -m xxx.py`作用是把`xxx.py`文件当做模块启动

`python xxx.py`和`python -m xxx.py`是两种加载`.py`文件的方式，前者叫做直接运行，后者把脚本当作模块来启动（但是该脚本的`__name__`属性值仍然为`main` ）

不同的加载`.py`文件的方式，主要是影响`sys.path`这个属性。`sys.path`就相当于`Linux`中的`PATH`。

假设目录如下：
```shell
# 目录结构如下
package/
	__init__.py
	mod1.py
package2/
	__init__.py
	run.py
```

`run.py`文件内容如下：
```python
import sys
from package import mod1
print(sys.path)
```

直接启动是把`run.py`文件所在的目录放到了`sys.path`属性中。模块启动是把你输入命令的目录（也就是当前路径），放到了`sys.path`属性中。

```shell
# 直接启动
python package2/run.py
# 模块启动
python -m package2.run
```

这时如果直接启动就会报错：`ImportError: No module named package`，因为`import`的`package`模块的路径此时不在`sys.path`中，而使用模块启动则不会出现问题。



## Python标准库

### 1. argparse库

[官方`argparse`文档](https://docs.python.org/3/library/argparse.html?highlight=argparse#module-argparse)，`python`还为其做了个[tutorial](https://docs.python.org/3/howto/argparse.html#id1)

`argsparse`是`python`的命令行解析的标准模块，内置于`python`，不需要安装。这个库可以让我们直接在命令行中就可以向程序中传入参数并让程序运行。

`python`里还有两个`modules`有着和`argparse`同样的作用，叫做`getopt`和`optparse`，其中`getopt`和`C`语言里的`getopt()`是类似的，而`argparse`就是基于`optparse`开发的，但后者在3.2版本之后就不再更新了，`python`只继续维护`argparse`。

写一个脚本`test.py`
```python
import argparse
parser = argparse.ArgumentParser()
parser.parse_args()
```

然后运行：

```shell
$ python test.py
$ python test.py --help
usage: test.py [-h]

options:
  -h, --help  show this help message and exit
$ python test.py --verbose
usage: test.py [-h]
test.py: error: unrecognized arguments: --verbose
$ python test.py foo
usage: test.py [-h]
test.py: error: unrecognized arguments: foo
```

首先，我们运行了`test.py`文件，没有传入任何参数，无事发生。第二次，我们使用了`--help`参数，这时候输出了`argparse`模块的`descriptions`。`--help`和`-h`表示的意思是一样的，它是我们唯一不需要定义就可以获取的功能（因为在源代码中的类里已经内置了这个method）。第三次第四次，因为我们源代码里并没有定义任何参数（不管是positional arguments还是optional arguments），所以会报错。

下面具体来看positional arguments和optional arguments的用法。

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo")
args = parser.parse_args()
print(args.echo)
```

运行上述代码：

```shell
$ python test.py
usage: test.py [-h] echo
test.py: error: the following arguments are required: echo
$ python test.py --help
usage: prog.py [-h] echo

positional arguments:
  echo

options:
  -h, --help  show this help message and exit
$ python test.py foo
foo
```

`parser`是`argparse`库里的`ArgumentParser`类的一个实例，然后使用`parser`的`add_argument()`方法来添加一个变量，名字叫做`echo`，这是我们需要在命令行里赋值的一个positional argument，不给的话就会报错。这时候只有一个positional argument，所以还看不出来赋值和positional arguments是如何一一对应的。

`parser`还有一个method叫做`parse_args()`，其会返回所有的`arguments`。如果`test.py`里没有包含`print(args.echo)`的话，运行`python test.py foo`是不会有输出的。

`parser.parser_args()`返回的`args`实际上类似于一个字典。

下面的例子表明我们该如何修改`help`会打印出的内容，真正做到可以对定义的`arguments`给用户以解释。

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo", help="echo the string you use here")
args = parser.parse_args()
print(args.echo)
```

运行结果为：

```shell
$ python test.py -h
usage: prog.py [-h] echo

positional arguments:
  echo        echo the string you use here

options:
  -h, --help  show this help message and exit
```

再修改一下源代码：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number")
args = parser.parse_args()
print(args.sqaure**2)
```

运行结果是：

```shell
$ python test.py 4
Traceback (most recent call last):
  File "prog.py", line 5, in <module>
    print(args.square**2)
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
```

上述代码出错是因为在最后的平方计算那里出错，如果没有任何说明的话，那么`argparse`模块将任意的输入arguments都当作`strings`来对待，除非在定义argument的时候就说明：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("sqaure", help="display a square of a given number", type=int)
args = parser.parse_args()
print(args.square**2)
```

运行结果为：

```shell
$ python test.py 4
16
$ python test.py four
usage: prog.py [-h] square
prog.py: error: argument square: invalid int value: 'four'
```

如果我们定义了多个positional arguments，那么在传入参数的时候，按照将前面的值传入先定义的参数，以此向后的顺序，将命令行里的各个值赋值给各个positional arguments：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("first_name", help="Your first name")
parser.add_argument("last_name", help="Your last name")
args = parser.parser_args()
print(args.first_name + " " + args.last_name)
```

运行结果为：
```shell
$ python test.py "alan" "turing"
alan turing
$ python test.py "turing" "alan"
turing alan
```

下面来看`argparse`模块里的`optional arguments`的用法。

为了在命令行中避免上述位置参数的bug（容易忘了顺序），可以使用可选参数，这个有点像关键词传参，但是在命令行里传入参数值的时候需要在关键词前面加`--`

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbosity", help="increase output verbosity")
args = parser.parse_args()
if args.verbosity:
    print("verbosity turned on")
```

运行结果为：

```shell
$ python test.py --verbosity 1
verbosity turned on
$ python test.py
$ python test.py -h
usage: prog.py [-h] [--verbosity VERBOSITY]

options:
  -h, --help            show this help message and exit
  --verbosity VERBOSITY
                        increase output verbosity
$ python test.py --verbosity
usage: prog.py [-h] [--verbosity VERBOSITY]
prog.py: error: argument --verbosity: expected one argument
```

在使用`add_argument()`方法的时候，在参数`verbosity`前面加了`--`，就表示这个参数是optional argument。optional argument顾名思义是可选的，也就是说我们不给它传入值也是不会报错的。实际上，`python`内部，如果我们不给optional argument传入值，也没有设置`default`的值，那么`python`默认给它赋值`None`，这也就是为什么在不赋值的时候，上述`if`判断就会是`false`的原因。在使用`--verbosity`变量的时候，可以这么写：`--verbosity=1`，也可以这么写（用一个空格隔开）：`--verbosity 1`

接下来再来修改以下源代码，让`--verbosity`这个argument更有实际意义：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase the output verbosity", action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

运行结果为：

```shell
$ python test.py --verbose
verbosity turned on
$ python test.py --verbose 1
usage: prog.py [-h] [--verbose]
prog.py: error: unrecognized arguments: 1
$ python3 prog.py --help
usage: prog.py [-h] [--verbose]

options:
  -h, --help  show this help message and exit
  --verbose   increase output verbosity
```

源代码里，在定义`--verbose`参数的时候，在`add_argument()`方法里使用了一个参数`action`，其可以赋值`"store_true"`和`"store_false"`，这个时候，这个参数就变成了一个`flag`，也就是说此时在命令行里，如果使用这个参数，那么就不再需要也不能给它赋值（上述代码赋值的时候报错）。如果`action="store_true"`，那么在命令行里提到了这个参数，则这个参数赋值就是`True`，如果没有提到，那么就是`False`。如果`action="store_false"`，那么在命令行里提到了这个参数，则这个参数赋值就是`False`，如果没有提到，那么就是`True`。

`add_argument()`方法还有个`default`参数，其对于optional argument来说，如果不赋值的话，就使用`default`参数的值，赋值的话，就不使用它。但如果这个optional argument在定义的时候已经使用了`action`参数了，其和`default`之间的优先级如下所示：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--pa", action="store_true")
parser.add_argument("--pb", action="store_true", default=True)
parser.add_argument("--pc", action="store_true", default=False)
parser.add_argument("--pd", action="store_false")
parser.add_argument("--pe", action="store_false", default=True)
parser.add_argument("--pf", action="store_true", default=False)

args = parser.parse_args()
print(args)
```

运行结果为：

```shell
$ python test.py --pa --pb --pc --pd --pe --pf
Namespace(pa=True, pb=True, pc=True, pd=False, pe=False, pf=False)
$ python test.py
Namespace(pa=False, pb=True, pc=False, pd=True, pe=True, pf=False)
```

也就是说，如果出现了这个optional argument，那么就以`action`为准，如果没有出现，就以`default`为准。

对于optional argument来说，用一个带有`-`开头的argument同样指的是这个argument是一个optional argument：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
parser.add_argument("-a", help="just for fun", action="store_false")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
if not args.a:
    print("just for fun")
```

运行结果为：

```shell
$ python test.py -v -a
verbosity turned on
just for fun
$ python test.py --help
usage: prog.py [-h] [-v] [-a]

options:
  -h, --help     show this help message and exit
  -v, --verbose  increase output verbosity
  -a, just for fun
```

`-v`和`--verbose`现在表示的是同一个argument了，在`help`文档里也写明了这个意思。还要注意的是，尽管在`add_argument()`里使用`--verbose`作为输入，但实际上在`args`里，可以看到变量名还是`verbose`，也就是说`--`只是用来表示其是`optional argument`，变量名还是`verbose`。

`add_argument()`有一个`required`参数可以设置该参数是否必需。

```python
import argparse

parser = argparse.ArgumentParser(description='姓名')
parser.add_argument('--family', type=str, help='姓')
parser.add_argument('--name', type=str, required=True, default='', help='名')
args = parser.parse_args()

print(args.family+args.name)
'''

在命令行中输入`python test.py --family='Turing'`，运行结果

```shell
usage: test.py [-h] [--family FAMILY] --name NAME
demo.py: error: the following arguments are required: --name
```

因为可选参数`name`的`required=True`，所以必须要传入。如果我们将其更改为`False`，程序运行结果

```shell
Turing
```

### 2. os标准库

#### 2.1 os.mkdir()和os.makedirs()函数

`os.mkdir()`和`os.makedirs()`都是用来创建目录的函数。

对于目录`Test/path_01/path_02/path_03`，`os.mkdir()`创建路径中的最后一级目录，即：只创建`path_03`目录，而如果之前的目录不存在并且也需要创建的话，就会报错。`os.makedirs()`创建多层目录，即：`Test,path_01,path_02,path_03`如果都不存在的话，会自动创建，但是如果`path_03`也就是最后一级目录已存在的话就会抛出`FileExistsError`异常。

## Python第三方库

### 1. faiss库

参考：https://github.com/liqima/faiss_note

### 2. PIL库

#### 2.1 使用PIL库里的Image模块处理图片

`Image`模块是常见的读取并处理图片的`python`模块，但注意的是，直接读取的img是个`Image`特殊格式的文件：

```python
from PIL import Image
img = Image.open("xxx.png")
img
## 输出是 <PIL.PngImagePlugin.PngImageFile image mode=RGBA size=256x256 at 0x18192591880>
```

如果需要操作img，最简单的的方法是先将其转换为`numpy`格式，注意`Image`读取的图片的最后一个维度是channel，和`pytorch`默认的维度顺序也不同。

```python
import numpy as np
img_array = np.asarray(img)
## img_array里的每个值的范围是0到255，且是整数
print(img_array.shape)
## height x width x 3
```

对于和`pytorch`结合使用的情况，最常见的就是在自定义数据集函数的时候，因为神经网络的输入一般都要求数据在$$\left[-1, 1 \right]$$的范围，所以使用Image.open读取图片后，通常需要normalize所读取的图片数据：

```python
import numpy as np
from PIL import Image
import torch
from torchvision import transforms

target_size = 128
img = Image.open("xxx.png")
img = img.resize((target_size, target_size), resample=Image.BILINEAR)
img_array = np.asarray(img)..transpose((2, 0, 1)).reshape(1,3,target_size,target_size)
Transforms = transforms.Compose([transforms.Normalize((0.5,0.5,0.5), (0.5,0.5,0.5))])
img_tensor = Transforms(img_array)
## img_tensor的维度是1x3x128x128，值的范围是-1到1，现在就可以作为神经网络的输入了。
```

有时候将一张`png`图像使用`PIL`读入的时候，发现是一个四通道图像，即：RGBA，分别代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。其中Alpha通道一般用做透明度参数（大多情况下就等价于mask），这就是为啥透明图像都保存成了`png`格式。将4通道的`png`图像读入成3通道可以使用`PIL`的`Image.convert(" ")`方法

```python
from PIL import Image

img = Image.open('test.png')
# 将一个4通道转化为rgb三通道
img = img.convert("RGB")
```

> `PIL`包含九种不同模式：1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。使用`Image.convert()`可以在这九中模式中进行切换。
> * 模式`1`为二值图像，非黑即白，它每个像素用8个bit表示，0表示黑，255表示白。
> * 模式`L`为灰度图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。在`PIL`中，从模式`RGB`转换为`L`模式是按照下面的公式转换的：$$L = R \times 299 / 1000 + G \times 587 / 1000+ B \times 114 / 1000$$。
> * 模式`P`为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的。
> * `RGB`就是通常说的三原色。
> * `RGBA`就是上例上的在三原色的基础上增加了一个`alpha`通道。它的每个像素用32个bit表示，其中24个bit表示红色、绿色和蓝色三个通道，另外8个bit表示alpha通道，即透明通道。
> * 模式`CMYK`为32位彩色图像，它的每个像素用32个bit表示。模式`CMYK`就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓全彩印刷。四种标准颜色是：C（Cyan，青色，又称为天蓝色或是湛蓝）；M（Magenta，品红色，又称为洋红色；Y（Yellow，黄色）；K（Key Plate(blacK)，定位套版色（黑色））。PIL中`RGB`转换为`CMYK`的公式如下：$$C = 255 - R, M = 255 - G, Y = 255 - B, K = 0$$。
> * 模式`YCbCr`为24位彩色图像，它的每个像素用24个bit表示。`YCbCr`其中`Y`是指亮度分量，`Cb`指蓝色色度分量，而`Cr`指红色色度分量。人的肉眼对视频的`Y`分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。模式`RGB`转换为`YCbCr`的公式如下：$$Y= 0.257 \times R + 0.504 \times G + 0.098 \times B + 16, Cb = -0.148 \times R - 0.291 \times G + 0.439 \times B + 128, Cr = 0.439 \times R - 0.368 \times G - 0.071 \times B + 128$$。
> * 模式`I`为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，$$(0,255)$$之间的数字表示不同的灰度。在`PIL`中，从模式`RGB`转换为`I`模式是按照下面的公式转换的：$$I = R \times 299/1000 + G \times 587/1000 + B \times 114/1000$$。
> * 模式`F`为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，$$(0,255)$$之间的数字表示不同的灰度。在`PIL`中，从模式`RGB`转换为`F`模式是按照下面的公式转换的：$$F = R \times 299/1000 + G \times 587/1000 + B \times 114/1000$$。

使用`PIL`库读取图片的时候有时候会报错：`PIL Image "image file is truncated"`，这是因为有图像损坏的情况。希望程序能够自动化跳过这种损坏的图像的话，只需要在读取图片的程序开头加上：

```python
from PIL import ImageFile
ImageFile.LOAD_TRUNCATED_IMAGES = True
```

### 3. Matplotlib库

Matplotlib库是python里用于画图的最常见的库，主要用于画2D图，包括各种函数曲线，散点图，热力图等。


### 4. vedo库


### 5. pyvista库


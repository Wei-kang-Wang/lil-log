---
layout: post
comments: false
title: "Python"
date: 2021-12-30 01:09:00

---

> python相关的内容.


<!--more-->

# 总览

首先列出python的参考资料：

1. python的官方文档：https://docs.python.org/3/index.html
包括了tutorial（大致介绍了基本的python语法）、标准库、language reference（也就是详尽的从头到尾的python语法介绍）、C/CPP和python的接口文档手册等等。
2. Python的标准库：https://docs.python.org/3/library/index.html
介绍了Python自带的built-in functions，built-in types，built-in exceptions和各种modules
3. Numpy的官方文档：https://numpy.org/doc/stable/index.html
包括了基本的user guide（大致介绍了基本用法）、API（完整的内容介绍）、developer guide（给想开发的人的指南）。
4. Pandas库的官方文档：https://pandas.pydata.org/docs/
包括了基本的user guide（大致介绍了基本用法）、API（完整的内容介绍）、developer guide（给想开发的人的指南）。
5. Matplotlib库的官方文档：https://matplotlib.org/stable/index.html
6. Scikit-learn库的官方文档：https://scikit-learn.org/stable/index.html

本post不会重复参考资料里的内容，但可能会对其进行补充。本post主要会对重要的python内容进行介绍，比如说一些库（有的来自于标准库比如argparse，有的来自于著民第三方库，比如Numpy，但重要的库，比如说pytorch，还是会另开post来介绍），其中可能会综合汇总其他人博客里的内容（会标明出处），以达到对python常用内容可以迅速复习的目的。

# 1. argparse库

## 1.1 Python官方的argparse module文档

官方argparse module文档地址为：https://docs.python.org/3/library/argparse.html?highlight=argparse#module-argparse, 是标准库的一部分。

因为argparse module非常常用，python还为其做了个tutorial：https://docs.python.org/3/howto/argparse.html#id1 。

### 1.1.1 Argparse tutorial

argsparse是python的命令行解析的标准模块，内置于python，不需要安装。这个库可以让我们直接在命令行中就可以向程序中传入参数并让程序运行。

python里还有两个modules有着和argparse同样的作用，叫做getopt和optparse，其中getopt和C语言里的getopt()是类似的，而argparse就是基于optparse开发的，但后者在3.2版本之后就不再更新了，python只继续维护argparse。

#### 1.1.1.1 一个简单的例子

```python
import argparse
parser = argparse.ArgumentParser()
parser.parse_args()
```

将上述代码存为test.py，然后运行该文件：

```python
$ python test.py
$ python test.py --help
usage: test.py [-h]

options:
  -h, --help  show this help message and exit
$ python test.py --verbose
usage: test.py [-h]
test.py: error: unrecognized arguments: --verbose
$ python test.py foo
usage: test.py [-h]
test.py: error: unrecognized arguments: foo
```

* 首先，我们运行了test.py文件，没有传入任何参数，无事发生。
* 第二次，我们使用了--help参数，这时候输出了argparse模块的descriptions。--help和-h表示的意思是一样的，它是我们唯一不需要定义就可以获取的功能（因为在源代码中的类里已经内置了这个method）。
* 第三次第四次，因为我们源代码里并没有定义任何参数（不管是positional arguments还是optional arguments），所以会报错。

#### 1.1.1.2 argparse模块里的positional arguments的用法

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo")
args = parser.parse_args()
print(args.echo)
```

运行上述代码：

```python
$ python test.py
usage: test.py [-h] echo
test.py: error: the following arguments are required: echo
$ python test.py --help
usage: prog.py [-h] echo

positional arguments:
  echo

options:
  -h, --help  show this help message and exit
$ python test.py foo
foo
```

* parser是argparse包里的ArgumentParser类的一个实例，然后使用parser的add_argument() method来添加一个变量，名字叫做"echo"，这是我们需要在命令行里赋值的一个positional argument，不给的话就会报错。这时候只有一个positional argument，所以还看不出来赋值和positional arguments是如何一一对应的。
* parser还有一个method叫做parse_args()，其会返回所有的arguments。如果test.py里没有包含print(args.echo)的话，运行python test.py foo是不会有输出的。
* parser.parser_args()返回的args实际上类似于一个字典。

下面的例子表明我们该如何修改help会打印出的内容，真正做到可以对定义的arguments给用户以解释。

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo", help="echo the string you use here")
args = parser.parse_args()
print(args.echo)
```

运行结果为：

```python
$ python test.py -h
usage: prog.py [-h] echo

positional arguments:
  echo        echo the string you use here

options:
  -h, --help  show this help message and exit
```

再修改一下源代码：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number")
args = parser.parse_args()
print(args.sqaure**2)
```

运行结果是：

```python
$ python test.py 4
Traceback (most recent call last):
  File "prog.py", line 5, in <module>
    print(args.square**2)
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
```

* 上述代码出错是因为在最后的平方计算那里出错，如果没有任何说明的话，那么argparse模块将任意的输入arguments都当作strings来对待，除非在定义argument的时候就说明：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("sqaure", help="display a square of a given number", type=int)
args = parser.parse_args()
print(args.square**2)
```

运行结果为：

```python
$ python test.py 4
16
$ python test.py four
usage: prog.py [-h] square
prog.py: error: argument square: invalid int value: 'four'
```

如果我们定义了多个positional arguments，那么在传入参数的时候，按照将前面的值传入先定义的参数，以此向后的顺序，将命令行里的各个值赋值给各个positional arguments：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("first_name", help="Your first name")
parser.add_argument("last_name", help="Your last name")
args = parser.parser_args()
print(args.first_name + " " + args.last_name)
```

运行结果为：
```python
$ python test.py "alan" "turing"
alan turing
$ python test.py "turing" "alan"
turing alan
```

#### 1.1.1.3 argparse模块里的optional arguments的用法

为了在命令行中避免上述位置参数的bug（容易忘了顺序），可以使用可选参数，这个有点像关键词传参，但是在命令行里传入参数值的时候需要在关键词前面加--

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbosity", help="increase output verbosity")
args = parser.parse_args()
if args.verbosity:
    print("verbosity turned on")
```

运行结果为：

```python
$ python test.py --verbosity 1
verbosity turned on
$ python test.py
$ python test.py -h
usage: prog.py [-h] [--verbosity VERBOSITY]

options:
  -h, --help            show this help message and exit
  --verbosity VERBOSITY
                        increase output verbosity
$ python test.py --verbosity
usage: prog.py [-h] [--verbosity VERBOSITY]
prog.py: error: argument --verbosity: expected one argument
```

* 在使用add_argument() method的时候，在参数verbosity前面加了--，就表示这个参数是optional argument。
* optional argument，顾名思义，是可选的，也就是说我们不给它传入值也是不会报错的。实际上，python内部，如果我们不给optional argument传入值，也没有设置default的值，那么python默认给它赋值None，这也就是为什么在不赋值的时候，上述if判断就会是false的原因。
* 在使用--verbosity变量的时候，可以这么写：--verbosity=1，也可以这么写（用一个空格隔开）：--verbosity 1。

接下来再来修改以下源代码，让--verbosity这个argument更有实际意义：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase the output verbosity", action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

运行结果为：

```python
$ python test.py --verbose
verbosity turned on
$ python test.py --verbose 1
usage: prog.py [-h] [--verbose]
prog.py: error: unrecognized arguments: 1
$ python3 prog.py --help
usage: prog.py [-h] [--verbose]

options:
  -h, --help  show this help message and exit
  --verbose   increase output verbosity
```

* 源代码里，在定义--verbose参数的时候，在add_argument method里使用了一个参数action，其可以赋值"store_true"和"store_false"，这个时候，这个参数就变成了一个flag，也就是说此时在命令行里，如果使用这个参数，那么就不再需要也不能给它赋值（上述代码赋值的时候报错）。如果action="store_true"，那么在命令行里提到了这个参数，则这个参数赋值就是True，如果没有提到，那么就是False。如果action="store_false"，那么在命令行里提到了这个参数，则这个参数赋值就是False，如果没有提到，那么就是True。


add_argument method还有个default参数，其对于optional argument来说，如果不赋值的话，就使用default参数的值，赋值的话，就不使用它。但如果这个optional argument在定义的时候已经使用了action参数了，其和default之间的优先级如下所示：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--pa", action="store_true")
parser.add_argument("--pb", action="store_true", default=True)
parser.add_argument("--pc", action="store_true", default=False)
parser.add_argument("--pd", action="store_false")
parser.add_argument("--pe", action="store_false", default=True)
parser.add_argument("--pf", action="store_true", default=False)

args = parser.parse_args()
print(args)
```

运行结果为：

```python
$ python test.py --pa --pb --pc --pd --pe --pf
Namespace(pa=True, pb=True, pc=True, pd=False, pe=False, pf=False)
$ python test.py
Namespace(pa=False, pb=True, pc=False, pd=True, pe=True, pf=False)
```

* 也就是说，如果出现了这个optional argument，那么就以action为准，如果没有出现，就以default为准。

##### 1.1.1.3.1 short options

也就是对于optional argument来说，用一个带有-开头的argument同样指的是这个optional argument，只不过optional argument需要有--开头：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

运行结果为：

```python
$ python test.py -v
verbosity turned on
$ python test.py --help
usage: prog.py [-h] [-v]

options:
  -h, --help     show this help message and exit
  -v, --verbose  increase output verbosity
```

* -v和--verbose现在表示的是一个argument了，而且注意在help文档里也写明了这个意思。
* 还要注意的是，尽管在add_argument method里使用--verbose作为输入，但实际上在args里，可以看到变量名还是verbose，也就是说--只是用来表示其是optional argument，变量名还是verbose。





**1.8. 必需参数**

add_argument有一个required参数可以设置该参数是否必需。

```python
import argparse

parser = argparse.ArgumentParser(description='姓名')
parser.add_argument('--family', type=str, help='姓')
parser.add_argument('--name', type=str, required=True, default='', help='名')
args = parser.parse_args()

print(args.family+args.name)
'''

在命令行中输入 python test.py --family='Turing'，运行结果

```python
usage: test.py [-h] [--family FAMILY] --name NAME
demo.py: error: the following arguments are required: --name
```

因为可选参数name的required=True，所以必须要传入。如果我们将其更改为False，程序运行结果

```python
Turing
```



## 2. faiss模块

参考：https://github.com/liqima/faiss_note


## 3. Python里的描述符

https://waynerv.com/posts/python-descriptor-in-detail/

## 4. Python的metaclass

https://segmentfault.com/a/1190000007255412

## 5. decorator和descripter

https://www.jianshu.com/p/cc1e8a18b708

## 6. Python里的super函数

https://blog.csdn.net/wo198711203217/article/details/84097274

## 7. Python读取.npy和.npz文件

npy以及npz这两种文件格式，是python第三方库numpy才能够保存和读取的文件类型。

对于npy文件只需要将numpy这个第三方库导入进来，然后调用方法生成数组或者矩阵对象。再使用save()方法并传入文件保存路径以及数据对象，就可以将其保存为npy文件，代码如下：

```python
import numpy as np
data_1 = np.zeros((3, 3))
np.save("test.npy", data_1)
```

唯一需要注意这个文件必须是以npy作为后缀名的，而读取文件就更加简单了，调用load()方法并传入文件路径就可以直接把npy文件数据给读取出来。

npz文件是以字典形式来保存数据的，它会给传进来的每一个数组分配一个单独存在不重复的字典键。只需要在save后面加上一个字母z就能够将其保存为npz文件，其余的语法和上面示例中是一样的，代码如下：

```python
import numpy as np
data_1 = np.zeros((3, 3))
np.savez("test.npz", data_1)
```

不过读取npz文件的方法就有点不同了，它需要先将其调用load()方法把数据都给取出来。然后再通过循环迭代字典键的方式才可以得到具体对应的数据，代码示例如下所示：

```python
datas = np.load("test.npz")
#第一种方法
print(datas.files)  #['arr_0']
print(datas['arr_0'])
#第二种方法
for key, arr in datas.items():
  print(key, ": ", arr)
```

## 8. PIL库

### 8.1 使用PIL库里的Image模块处理图片

```python
from PIL import Image
img = Image.open("xxx.png")
```

Image模块是常见的读取并处理图片的python模块，但注意的是，直接读取的img是个Image特殊格式的文件：

```shell
>>> img
>>> <PIL.PngImagePlugin.PngImageFile image mode=RGBA size=256x256 at 0x18192591880>
```

如果需要操作img，最简单的的方法是将其转换为numpy格式：

```python
import numpy as np
img_array = np.asarray(img)
## img_array里的每个值的范围是0到255，且是整数
print(img_array.shape)
## height x width x 3
```

注意Image读取的图片的dimension的channel维度是最后一个，和pytorch默认的维度顺序也不同。

在pytorch的自定义dataset函数里，因为网络的输入一般都会normalize到$$\left[-1, 1 \right]$$的范围，所以在dataset里使用Image.open读取图片后，常见的操作是：

```python
import numpy as np
from PIL import Image
import torch
from torchvision import transforms

target_size = 128
img = Image.open("xxx.png")
img = img.resize((target_size, target_size), resample=Image.BILINEAR)
img_array = np.asarray(img)..transpose((2, 0, 1)).reshape(1,3,target_size,target_size)
Transforms = transforms.Compose([transforms.Normalize((0.5,0.5,0.5), (0.5,0.5,0.5))])
img_tensor = Transforms(img_array)
## img_tensor的维度是1x3x128x128，值的范围是-1到1，现在就可以作为神经网络的输入了。
```





---

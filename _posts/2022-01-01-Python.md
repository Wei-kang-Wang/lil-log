---
layout: post
comments: false
title: "Python"
date: 2021-12-30 01:09:00

---

> python相关的内容.


<!--more-->

# 总览

首先列出python的参考资料：

1. python的官方文档：https://docs.python.org/3/index.html
包括了tutorial（大致介绍了基本的python语法）、标准库、language reference（也就是详尽的从头到尾的python语法介绍）、C/CPP和python的接口文档手册等等。
2. Python的标准库：https://docs.python.org/3/library/index.html
介绍了Python自带的built-in functions，built-in types，built-in exceptions和各种modules
3. Numpy的官方文档：https://numpy.org/doc/stable/index.html
包括了基本的user guide（大致介绍了基本用法）、API（完整的内容介绍）、developer guide（给想开发的人的指南）。
4. Pandas库的官方文档：https://pandas.pydata.org/docs/
包括了基本的user guide（大致介绍了基本用法）、API（完整的内容介绍）、developer guide（给想开发的人的指南）。
5. Matplotlib库的官方文档：https://matplotlib.org/stable/index.html
6. Scikit-learn库的官方文档：https://scikit-learn.org/stable/index.html

本post不会重复参考资料里的内容，但可能会对其进行补充。本post主要会对重要的python内容进行介绍，比如说一些库（有的来自于标准库比如argparse，有的来自于著民第三方库，比如Numpy，但重要的库，比如说pytorch，还是会另开post来介绍），其中可能会综合汇总其他人博客里的内容（会标明出处），以达到对python常用内容可以迅速复习的目的。

# 1. argparse库

## 1.1 Python官方的argparse module文档

官方argparse module文档地址为：https://docs.python.org/3/library/argparse.html?highlight=argparse#module-argparse, 是标准库的一部分。

因为argparse module非常常用，python还为其做了个tutorial：https://docs.python.org/3/howto/argparse.html#id1 。

### 1.1.1 Argparse tutorial

argsparse是python的命令行解析的标准模块，内置于python，不需要安装。这个库可以让我们直接在命令行中就可以向程序中传入参数并让程序运行。

python里还有两个modules有着和argparse同样的作用，叫做getopt和optparse，其中getopt和C语言里的getopt()是类似的，而argparse就是基于optparse开发的，但后者在3.2版本之后就不再更新了，python只继续维护argparse。

#### 1.1.1.1 一个简单的例子

```python
import argparse
parser = argparse.ArgumentParser()
parser.parse_args()
```

将上述代码存为test.py，然后运行该文件：

```python
$ python test.py
$ python test.py --help
usage: test.py [-h]

options:
  -h, --help  show this help message and exit
$ python test.py --verbose
usage: test.py [-h]
test.py: error: unrecognized arguments: --verbose
$ python test.py foo
usage: test.py [-h]
test.py: error: unrecognized arguments: foo
```

* 首先，我们运行了test.py文件，没有传入任何参数，无事发生。
* 第二次，我们使用了--help参数，这时候输出了argparse模块的descriptions。--help和-h表示的意思是一样的，它是我们唯一不需要定义就可以获取的功能（因为在源代码中的类里已经内置了这个method）。
* 第三次第四次，因为我们源代码里并没有定义任何参数（不管是positional arguments还是optional arguments），所以会报错。

#### 1.1.1.2 argparse模块里的positional arguments的用法

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo")
args = parser.parse_args()
print(args.echo)
```

运行上述代码：

```python
$ python test.py
usage: test.py [-h] echo
test.py: error: the following arguments are required: echo
$ python test.py --help
usage: prog.py [-h] echo

positional arguments:
  echo

options:
  -h, --help  show this help message and exit
$ python test.py foo
foo
```

* parser是argparse包里的ArgumentParser类的一个实例，然后使用parser的add_argument() method来添加一个变量，名字叫做"echo"，这是我们需要在命令行里赋值的一个positional argument，不给的话就会报错。这时候只有一个positional argument，所以还看不出来赋值和positional arguments是如何一一对应的。
* parser还有一个method叫做parse_args()，其会返回所有的arguments。如果test.py里没有包含print(args.echo)的话，运行python test.py foo是不会有输出的。
* parser.parser_args()返回的args实际上类似于一个字典。

下面的例子表明我们该如何修改help会打印出的内容，真正做到可以对定义的arguments给用户以解释。

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("echo", help="echo the string you use here")
args = parser.parse_args()
print(args.echo)
```

运行结果为：

```python
$ python test.py -h
usage: prog.py [-h] echo

positional arguments:
  echo        echo the string you use here

options:
  -h, --help  show this help message and exit
```

再修改一下源代码：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("square", help="display a square of a given number")
args = parser.parse_args()
print(args.sqaure**2)
```

运行结果是：

```python
$ python test.py 4
Traceback (most recent call last):
  File "prog.py", line 5, in <module>
    print(args.square**2)
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'
```

* 上述代码出错是因为在最后的平方计算那里出错，如果没有任何说明的话，那么argparse模块将任意的输入arguments都当作strings来对待，除非在定义argument的时候就说明：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("sqaure", help="display a square of a given number", type=int)
args = parser.parse_args()
print(args.square**2)
```

运行结果为：

```python
$ python test.py 4
16
$ python test.py four
usage: prog.py [-h] square
prog.py: error: argument square: invalid int value: 'four'
```

如果我们定义了多个positional arguments，那么在传入参数的时候，按照将前面的值传入先定义的参数，以此向后的顺序，将命令行里的各个值赋值给各个positional arguments：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("first_name", help="Your first name")
parser.add_argument("last_name", help="Your last name")
args = parser.parser_args()
print(args.first_name + " " + args.last_name)
```

运行结果为：
```python
$ python test.py "alan" "turing"
alan turing
$ python test.py "turing" "alan"
turing alan
```

#### 1.1.1.3 argparse模块里的optional arguments的用法

为了在命令行中避免上述位置参数的bug（容易忘了顺序），可以使用可选参数，这个有点像关键词传参，但是在命令行里传入参数值的时候需要在关键词前面加--

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbosity", help="increase output verbosity")
args = parser.parse_args()
if args.verbosity:
    print("verbosity turned on")
```

运行结果为：

```python
$ python test.py --verbosity 1
verbosity turned on
$ python test.py
$ python test.py -h
usage: prog.py [-h] [--verbosity VERBOSITY]

options:
  -h, --help            show this help message and exit
  --verbosity VERBOSITY
                        increase output verbosity
$ python test.py --verbosity
usage: prog.py [-h] [--verbosity VERBOSITY]
prog.py: error: argument --verbosity: expected one argument
```

* 在使用add_argument() method的时候，在参数verbosity前面加了--，就表示这个参数是optional argument。
* optional argument，顾名思义，是可选的，也就是说我们不给它传入值也是不会报错的。实际上，python内部，如果我们不给optional argument传入值，也没有设置default的值，那么python默认给它赋值None，这也就是为什么在不赋值的时候，上述if判断就会是false的原因。
* 在使用--verbosity变量的时候，可以这么写：--verbosity=1，也可以这么写（用一个空格隔开）：--verbosity 1。

接下来再来修改以下源代码，让--verbosity这个argument更有实际意义：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--verbose", help="increase the output verbosity", action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

运行结果为：

```python
$ python test.py --verbose
verbosity turned on
$ python test.py --verbose 1
usage: prog.py [-h] [--verbose]
prog.py: error: unrecognized arguments: 1
$ python3 prog.py --help
usage: prog.py [-h] [--verbose]

options:
  -h, --help  show this help message and exit
  --verbose   increase output verbosity
```

* 源代码里，在定义--verbose参数的时候，在add_argument method里使用了一个参数action，其可以赋值"store_true"和"store_false"，这个时候，这个参数就变成了一个flag，也就是说此时在命令行里，如果使用这个参数，那么就不再需要也不能给它赋值（上述代码赋值的时候报错）。如果action="store_true"，那么在命令行里提到了这个参数，则这个参数赋值就是True，如果没有提到，那么就是False。如果action="store_false"，那么在命令行里提到了这个参数，则这个参数赋值就是False，如果没有提到，那么就是True。


add_argument method还有个default参数，其对于optional argument来说，如果不赋值的话，就使用default参数的值，赋值的话，就不使用它。但如果这个optional argument在定义的时候已经使用了action参数了，其和default之间的优先级如下所示：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--pa", action="store_true")
parser.add_argument("--pb", action="store_true", default=True)
parser.add_argument("--pc", action="store_true", default=False)
parser.add_argument("--pd", action="store_false")
parser.add_argument("--pe", action="store_false", default=True)
parser.add_argument("--pf", action="store_true", default=False)

args = parser.parse_args()
print(args)
```

运行结果为：

```python
$ python test.py --pa --pb --pc --pd --pe --pf
Namespace(pa=True, pb=True, pc=True, pd=False, pe=False, pf=False)
$ python test.py
Namespace(pa=False, pb=True, pc=False, pd=True, pe=True, pf=False)
```

* 也就是说，如果出现了这个optional argument，那么就以`action`为准，如果没有出现，就以`default`为准。

##### 1.1.1.3.1 short options

也就是对于optional argument来说，用一个带有`-`开头的`argument`同样指的是这个optional argument，只不过optional argument需要有`--`开头：

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
args = parser.parse_args()
if args.verbose:
    print("verbosity turned on")
```

运行结果为：

```python
$ python test.py -v
verbosity turned on
$ python test.py --help
usage: prog.py [-h] [-v]

options:
  -h, --help     show this help message and exit
  -v, --verbose  increase output verbosity
```

* `-v`和`--verbose`现在表示的是一个`argument`了，而且注意在`help`文档里也写明了这个意思。
* 还要注意的是，尽管在`add_argument method`里使用`--verbose`作为输入，但实际上在`args`里，可以看到变量名还是`verbose`，也就是说`--`只是用来表示其是`optional argument`，变量名还是`verbose`。





**1.8. 必需参数**

`add_argument`有一个`required`参数可以设置该参数是否必需。

```python
import argparse

parser = argparse.ArgumentParser(description='姓名')
parser.add_argument('--family', type=str, help='姓')
parser.add_argument('--name', type=str, required=True, default='', help='名')
args = parser.parse_args()

print(args.family+args.name)
'''

在命令行中输入`python test.py --family='Turing'`，运行结果

```python
usage: test.py [-h] [--family FAMILY] --name NAME
demo.py: error: the following arguments are required: --name
```

因为可选参数`name`的`required=True`，所以必须要传入。如果我们将其更改为`False`，程序运行结果

```python
Turing
```



## 2. faiss模块

参考：https://github.com/liqima/faiss_note


## 3. Python里的描述符

https://waynerv.com/posts/python-descriptor-in-detail/

## 4. Python的metaclass

https://segmentfault.com/a/1190000007255412

## 5. decorator和descripter

https://www.jianshu.com/p/cc1e8a18b708

## 6. Python里的super函数

https://blog.csdn.net/wo198711203217/article/details/84097274

## 7. Python常见I/O文件格式

### 7.1 Python读取.npy和.npz文件

`npy`以及`npz`这两种文件格式，是`python`第三方库`numpy`才能够保存和读取的文件类型。

对于`npy`文件只需要将`numpy`这个第三方库导入进来，然后调用方法生成数组或者矩阵对象。再使用`save()`方法并传入文件保存路径以及数据对象，就可以将其保存为`npy`文件，代码如下：

```python
import numpy as np
data_1 = np.zeros((3, 3))
np.save("test.npy", data_1)
```

唯一需要注意这个文件必须是以`npy`作为后缀名的，而读取文件就更加简单了，调用`load()`方法并传入文件路径就可以直接把`npy`文件数据给读取出来。

`npz`文件是以字典形式来保存数据的，它会给传进来的每一个数组分配一个单独存在不重复的字典键。只需要在`save`后面加上一个字母`z`就能够将其保存为`npz`文件，其余的语法和上面示例中是一样的，代码如下：

```python
import numpy as np
data_1 = np.zeros((3, 3))
np.savez("test.npz", data_1)
```

不过读取`npz`文件的方法就有点不同了，它需要先将其调用`load()`方法把数据都给取出来。然后再通过循环迭代字典键的方式才可以得到具体对应的数据，代码示例如下所示：

```python
datas = np.load("test.npz")
#第一种方法
print(datas.files)  #['arr_0']
print(datas['arr_0'])
#第二种方法
for key, arr in datas.items():
  print(key, ": ", arr)
```

## 7.2 使用pickle存储读取字典

对于字典类型数据，`python`最常用的是`pickle`包来读取和存储，如下是利用`pickle`来存储字典和读取字典的例子

```python
import pickle
 
a_dict = {'da': 111, 2: [23,1,4], '23': {1:2,'d':'sad'}}
 
# pickle a variable to a file
with open('pickle_example.pickle', 'wb') as f:
    pickle.dump(a_dict, file)

with open('pickle_example.pickle', 'rb') as file:
    a_dict1 =pickle.load(file)

## a_dict1文件就直接是一个字典
```

## 8. PIL库

### 8.1 使用PIL库里的Image模块处理图片

`Image`模块是常见的读取并处理图片的`python`模块，但注意的是，直接读取的img是个`Image`特殊格式的文件：

```python
from PIL import Image
img = Image.open("xxx.png")
img
## 输出是 <PIL.PngImagePlugin.PngImageFile image mode=RGBA size=256x256 at 0x18192591880>
```

如果需要操作img，最简单的的方法是先将其转换为`numpy`格式，注意`Image`读取的图片的最后一个维度是channel，和`pytorch`默认的维度顺序也不同。

```python
import numpy as np
img_array = np.asarray(img)
## img_array里的每个值的范围是0到255，且是整数
print(img_array.shape)
## height x width x 3
```

对于和`pytorch`结合使用的情况，最常见的就是在自定义数据集函数的时候，因为神经网络的输入一般都要求数据在$$\left[-1, 1 \right]$$的范围，所以使用Image.open读取图片后，通常需要normalize所读取的图片数据：

```python
import numpy as np
from PIL import Image
import torch
from torchvision import transforms

target_size = 128
img = Image.open("xxx.png")
img = img.resize((target_size, target_size), resample=Image.BILINEAR)
img_array = np.asarray(img)..transpose((2, 0, 1)).reshape(1,3,target_size,target_size)
Transforms = transforms.Compose([transforms.Normalize((0.5,0.5,0.5), (0.5,0.5,0.5))])
img_tensor = Transforms(img_array)
## img_tensor的维度是1x3x128x128，值的范围是-1到1，现在就可以作为神经网络的输入了。
```

有时候将一张`png`图像使用`PIL`读入的时候，发现是一个四通道图像，即：RGBA，分别代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。其中Alpha通道一般用做透明度参数（大多情况下就等价于mask），这就是为啥透明图像都保存成了`png`格式。将4通道的`png`图像读入成3通道可以使用`PIL`的`Image.convert(" ")`方法

```python
from PIL import Image

img = Image.open('test.png')
# 将一个4通道转化为rgb三通道
img = img.convert("RGB")
```

> `PIL`包含九种不同模式：1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。使用`Image.convert()`可以在这九中模式中进行切换。
> * 模式`1`为二值图像，非黑即白，它每个像素用8个bit表示，0表示黑，255表示白。
> * 模式`L`为灰度图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。在`PIL`中，从模式`RGB`转换为`L`模式是按照下面的公式转换的：$$L = R \times 299 / 1000 + G \times 587 / 1000+ B \times 114 / 1000$$。
> * 模式`P`为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的。
> * `RGB`就是通常说的三原色。
> * `RGBA`就是上例上的在三原色的基础上增加了一个`alpha`通道。它的每个像素用32个bit表示，其中24个bit表示红色、绿色和蓝色三个通道，另外8个bit表示alpha通道，即透明通道。
> * 模式`CMYK`为32位彩色图像，它的每个像素用32个bit表示。模式`CMYK`就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓全彩印刷。四种标准颜色是：C（Cyan，青色，又称为天蓝色或是湛蓝）；M（Magenta，品红色，又称为洋红色；Y（Yellow，黄色）；K（Key Plate(blacK)，定位套版色（黑色））。PIL中`RGB`转换为`CMYK`的公式如下：$$C = 255 - R, M = 255 - G, Y = 255 - B, K = 0$$。
> * 模式`YCbCr`为24位彩色图像，它的每个像素用24个bit表示。`YCbCr`其中`Y`是指亮度分量，`Cb`指蓝色色度分量，而`Cr`指红色色度分量。人的肉眼对视频的`Y`分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。模式`RGB`转换为`YCbCr`的公式如下：$$Y= 0.257 \times R + 0.504 \times G + 0.098 \times B + 16, Cb = -0.148 \times R - 0.291 \times G + 0.439 \times B + 128, Cr = 0.439 \times R - 0.368 \times G - 0.071 \times B + 128$$。
> * 模式`I`为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，$$(0,255)$$之间的数字表示不同的灰度。在`PIL`中，从模式`RGB`转换为`I`模式是按照下面的公式转换的：$$I = R \times 299/1000 + G \times 587/1000 + B \times 114/1000$$。
> * 模式`F`为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，$$(0,255)$$之间的数字表示不同的灰度。在`PIL`中，从模式`RGB`转换为`F`模式是按照下面的公式转换的：$$F = R \times 299/1000 + G \times 587/1000 + B \times 114/1000$$。

使用`PIL`库读取图片的时候有时候会报错：`PIL Image "image file is truncated"`，这是因为有图像损坏的情况，比如下图：



希望程序能够自动化跳过这种损坏的图像的话，只需要在读取图片的程序开头加上：

```python
from PIL import ImageFile
ImageFile.LOAD_TRUNCATED_IMAGES = True
```

---

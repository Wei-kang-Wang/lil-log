---
layout: post
comments: false
title: "各种系统、平台、环境的安装"
date: 2022-05-01 01:09:00

---

> 这个post是有关各种系统、环境、平台的安装指南。


<!--more-->

{: class="table-of-content"}
* TOC
{:toc}

---


## Linux系统用Anaconda安装pytorch + CUDA + cuDNN

**1. 安装Anaconda**

从Anaconda官网下载安装所用的的sh文件（比如说Anaconda3-5.3.1-Linux-x86_64.sh），上传至Linux系统。

在Linux系统里打开bash，cd到要上述安装文件所在目录下进行操作 ，然后输入：

```shell
bash -u Anaconda3-5.3.1-Linux-x86_64.sh
```

安装成功后，输入：

```shell
source ~/.bashrc
```

到此Anaconda安装成功。可以通过下面代码检查是否安装成功：

```shell
python
```

显示下面的样子，则说明安装正确：

![pic1]({{ '/assets/images/install-1.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

输入下面指令退出：

```shell
quit()
```

**2. 了解操作系统内核、显卡、编译器等基本信息**

**2.1 查看自己操作系统的版本信息**

```shell
cat /etc/issue
```

或者

```shell
cat /etc/lsb-release
```

![pic2]({{ '/assets/images/install-2.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

![pic3]({{ '/assets/images/install-3.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

**2.2 查看服务器显卡信息**

```shell
lspci | grep -i nvidia
```
用于查看全部的显卡信息。

![pic4]({{ '/assets/images/install-4.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

如果已经安装了显卡驱动，则可以用下述指令查看：

```shell
nvidia-smi
```
![pic5]({{ '/assets/images/install-5.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

**2.3 查看安装的显卡驱动的信息**

```shell
cat /proc/driver/nvidia/version
```

![pic6]({{ '/assets/images/install-6.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

**3. 显卡驱动安装**

如果要安装显卡驱动，需要根据操作系统的版本进行选择。

**3.1 多版本的gcc和g++**

gcc和g++是很多驱动安装过程中需要使用的编译器，很多时候由于编译器版本的不对应会使得安装出现很多莫民奇妙的错误，根据经验，现在的CUDA 10.1的话，也可以使用的是4.8，因此最好选择4.8-5.4之间的版本比较好，

首先查看系统的gcc和g++版本：

```shell
gcc --version
g++ --version
```

![pic7]({{ '/assets/images/install-7.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

之后安装新版本的gcc以及g++：

```shell
sudo apt-get update 
sudo apt get update                                                        /*对需要的软件包等进行必要的更新。*/
sudo apt-get install gcc-4.9
sudo apt-get install g++-4.9                                               /*用于安装对应版本的gcc以及g++。注意自己需要的版本自己修改。*/
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 20
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 20

/*这两行用于将刚安装的gcc和g++类似于注册的操作加入到bin中，用于可选择操作。也就是说通过这个操作不断向系统注册新的gcc和g++版本。*/

update-alternatives --config gcc
update-alternatives --config g++                                           /*用于对版本进行选择。进入之后根据提示完成选择即可。如果权限不够加sudo */
```

![pic8]({{ '/assets/images/install-8.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

一般我们是使用4.8-5.4之间的版本编译器即可。如果还是出现错误的话，首选的操作应该是卸载显卡驱动重装显卡驱动，成功率最高。

**3.2 显卡驱动安装**

如果需要安装显卡驱动的话，需要先将旧版本的显卡驱动卸载：

```shell
sudo apt-get remove --purge nvidia*
```

此外，安装之前，需要先禁用一个东西。nouveau。

打开文件blacklist.conf：

```shell
sudo vim /etc/modprobe.d/blacklist.conf
```

在文件的最后面加入以下的内容:

```shell
blacklist nouveau
blacklist lbm-nouveau
options nouveau modeset=0
alias nouveau off
alias lbm-nouveau off
```

检查操作是否成功：

```shell
lsmod | grep nouveau   /* 没显示即成功。 */
```

显卡驱动的安装比较简单，直接到官网进行对应的驱动的下载。

![pic9]({{ '/assets/images/install-9.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

![pic10]({{ '/assets/images/install-10.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

将下载好的显卡驱动上传到服务器进行安装。

![pic11]({{ '/assets/images/install-11.png' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

采用该命令进行驱动的安装：

```shell
sudo ./NVIDIA-Linux-x86_64-430.34.run
```

安装完成之后，可以采用以下命令进行检查：

```shell
nvidia-smi
```

**4. CUDA及cuDNN的安装**

CUDA是GPU进行计算的运算平台，根据需要安装对应版本的cuda。

这里需要注意的是，最好在安装显卡驱动的时候选择对应的cuda版本，然后在安装cuda的时候的版本保持一致（虽然高版本的驱动也可以兼容低版本的cuda）。

首先，查看自己的显卡驱动版本以及支持的最大CUDA版本：

```shell
nvidia-smi
```

![pic12]({{ '/assets/images/install-12.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

进入英伟达提供的[GPU驱动和CUDA对应关系](https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html)

确认自己目前的GPU驱动是否符合自己要安装的CUDA版本，符合就进入下一步，不符合就安装更加高级的驱动。

**4.1 CUDA安装包下载**

[这是最新版本的CUDA下载界面](https://developer.nvidia.com/cuda-downloads)
[这是之前版本的CUDA下载界面](https://developer.nvidia.com/cuda-toolkit-archive)

以CUDA-10.2为例：

![pic13]({{ '/assets/images/install-13.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

利用下述代码下载CUDA并安装：

```shell
wget https://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run
sudo sh cuda_10.2.89_440.33.01_linux.run
```

也可以选择在浏览器中输入wget后面的网址，然后在本地进行下载再上传至服务器。

**4.2 cuDNN安装包下载**

通过[网址](https://developer.nvidia.com/rdp/cudnn-download)下载CUDNN，下载需要注册账号，登录以后，如下图选择合适的CUDA版本对应的CUDNN并选择CUDNN Library for Linux，开始下载，下载好以后将文件后缀名改为.tgz后上传至服务器。

![pic14]({{ '/assets/images/install-14.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

![pic15]({{ '/assets/images/install-15.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

注意Archived cuDNN Releases就可以找到过去版本的cudnn。


**4.3 CUDA的安装（非root用户安装）**

先给cuda可执行权限：

```shell
chmod +x cuda_10.2.89_440.33.01_linux.run
```

运行run文件:

```shell
sh cuda_10.2.89_440.33.01_linux.run
```

通过键盘方向键（↑，↓）和Enter键可以进行选择和进入（确定）。选择Continue并进入:

![pic16]({{ '/assets/images/install-16.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

输入accept进入:

![pic17]({{ '/assets/images/install-17.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

利用上下键与Enter勾选对话框，只安装CUDA Toolkit:

![pic18]({{ '/assets/images/install-18.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

选择Options并进入，然后我们需要修改Toolkit Options 、Library install path这两项的路径。

![pic19]({{ '/assets/images/install-19.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

修改Toolkit Options路径，选择Change Toolkit Install Path:

![pic20]({{ '/assets/images/install-20.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

将默认路径修改至个人目录下，点击Enter确认:

![pic21]({{ '/assets/images/install-21.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

将下面的选项取消选定，选择Done，确认退出:

![pic22]({{ '/assets/images/install-22.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

选择Library install path （Blank for system default）

![pic23]({{ '/assets/images/install-23.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

添加之前一样的路径并Enter确认退出

![pic24]({{ '/assets/images/install-24.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

选择Done返回上一层目录，修改路径完成，选择Install开始安装

![pic25]({{ '/assets/images/install-25.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

出现如下所示的安装信息则说明安装成功

![pic26]({{ '/assets/images/install-26.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

**4.4 修改环境变量**

输入vim ~/.bashrc进行环境变量的修改；
添加一下信息（每个人的路径是不同的，我的是/home/zhaoqc/cuda-10.2）并保存退出。

```shell
export CUDA_HOME=$CUDA_HOME:/home/zhaoqc/cuda-10.2
export PATH=$PATH:/home/zhaoqc/cuda-10.2/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/zhaoqc/cuda-10.2/lib64
```

输入source ~/.bashrc

**4.5 安装cuDNN**

解压cuDNN，输入以下命令进行解压

```shell
tar -zxvf cudnn-10.2-linux-x64-v8.0.0.39.tgz
```

此时当前目录下回出现一个./cuda的文件夹

![pic27]({{ '/assets/images/install-27.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

复制文件到CUDA安装目录

```shell
cp cuda/include/cudnn.h ../cuda-10.2/include/
cp cuda/lib64/libcudnn* ../cuda-10.2/lib64/
```

修改权限，cudnn安装完成

```shell
chmod a+r ../cuda-10.2/include/cudnn.h ../cuda-10.2/lib64/libcudnn*
```

查看是否安装成功，输入nvcc -V

![pic28]({{ '/assets/images/install-28.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}


**5. 安装PyTorch**

现在Anaconda里构建一个虚拟环境：

```shell
conda create -n pytorch_env python=3.8
```

上述指令会生成一个叫pytorch_env的虚拟环境，相当于在Anaconda里开了个小房间，我们之后的包都可以在这个地方安装，即使有问题也不会影响其它的小房间以及Anaconda，而且可以很容易删除，注意上述指令还强调了我们用的是python3.8环境。

安装完成之后，输入conda activate pytorch_env进入虚拟环境。下图里左边的括号内的名字就是环境的名字，请确认切换到pytorch_env这个名字的环境后再继续安装pytorch。

![pic29]({{ '/assets/images/install-29.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

**6. 常用conda命令**

新建一个Pyhon版本为3.8的环境

```shell
conda create -n name_of_environment python=3.8
```

删除掉一个环境

```shell
conda remove -n name_of_environment –all
```

查看安装了的环境

```shell
conda info –envs
```

安装一个软件

```shell
conda install some_package
```

查看当前环境装了哪些软件

```shell
conda list
```

复制一个环境并重新命名（老环境不会删除）

```shell
conda create –name new_name –clone old_name
```

清理包缓存

```shell
conda clean -p
```

清理tar包缓存

```shell
conda clean -t
```

**7. 参考文献**
* https://zhuanlan.zhihu.com/p/198161777
* https://blog.csdn.net/kingfoulin/article/details/98872965
* https://panpili.com/?p=1166
* https://blog.csdn.net/weixin_44100850/article/details/103308367


## Linux安装tmux

tmux是一个 terminal multiplexer（终端复用器），它可以启动一系列终端会话。

简单来说，安装tmux之前，一旦与服务器断开连接或者关闭xhell或其他shell终端，我们的服务器上运行的程序就会终止，而且输入的历史消息全部消失。因此如果我们希望整晚在服务器上跑代码，我们的电脑也要整晚一直连接着服务器。而安装了tmux之后，即使我们关闭了shell终端或者不幸与服务器断开连接，我们在服务器上的程序依然在运行。

**1. 有sudo权限的用户**

很简单，就一行：

```shell
sudo apt-get install tmux
```

**2. 无sudo权限的非root用户**

**2.1 下载**

下载tmux及其依赖软件。

```shell
wget -c https://github.com/tmux/tmux/releases/download/3.0a/tmux-3.0a.tar.gz
wget -c https://github.com/libevent/libevent/releases/download/release-2.1.11-stable/libevent-2.1.11-stable.tar.gz
wget -c https://ftp.gnu.org/gnu/ncurses/ncurses-6.2.tar.gz
```
**2.2 解压下载的包**

```shell
tar -xzvf tmux-3.0a.tar.gz
tar -xzvf libevent-2.1.11-stable.tar.gz
tar -xzvf ncurses-6.2.tar.gz
```

**2.3 分别源码安装，先安装两个依赖包**

libevent会安在 /tmux_depend/lib：

```shell
cd  libevent-2.1.11-stable
/* $HOME/tmux_depend是我的安装路径，大家可以修改 */
./configure --prefix=$HOME/tmux_depend --disable-shared
make && make install
```

ncurses会安在 /tmux_depend/include：

```shell
cd
cd  ncurses-6.2
./configure --prefix=$HOME/tmux_depend
make && make install
```

**2.4 安装tmux**

```shell
cd
cd  tmux-3.0a
./configure CFLAGS="-I$HOME/tmux_depend/include -I/$HOME/tmux_depend/include/ncurses" LDFLAGS="-L/$HOME/tmux_depend/lib -L/$HOME/tmux_depend/include/ncurses -L/$HOME/tmux_depend/include"
make
cp tmux  $HOME/tmux_depend/bin
```

**2.5 设置环境变量（此步骤建议手动添加到bashrc文件中）**

```shell
export PATH=$HOME/tmux_depend/bin:$PATH
source ~/.bashrc
```

到此即完成安装

**3. tmux常见指令以及用法**

1）新建会话，比如新创建一个会话以"ccc"命名

```shell
[root@Centos6 ~]# tmux new -s ccc
/*加上参数-d，表示在后台新建会话*/
root@bobo:~# tmux new -s shibo -d
root@bobo:~# tmux ls
shibo: 1 windows (created Tue Oct  2 19:22:32 2018) [135x35]
```
 
 
2）查看创建得所有会话

```shell
[root@Centos6 ~]# tmux ls
0: 1 windows (created Wed Aug 30 17:58:20 2017) [112x22](attached)    
/* 这里的attached表示该会话是当前会话 */
aaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]
ccc: 1 windows (created Wed Aug 30 17:01:05 2017) [112x22]
```
   
 
3）登录一个已知会话。即从终端环境进入会话。
 
第一个参数a也可以写成attach。后面的aaa是会话名称。

```shell
[root@Centos6 ~]# tmux a -t aaa 
```
 
4）退出会话不是关闭：
 
登到某一个会话后，先按键ctrl+b启动快捷键，再按d，这样就会退出该会话，但不会关闭会话。
 
如果直接ctrl + d，就会在退出会话的通话也关闭了该会话！
 
   
 
5）关闭会话（销毁会话）

```shell
[root@Centos6 ~]# tmux ls
aaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]
bbb: 1 windows (created Wed Aug 30 19:02:09 2017) [112x22]   
[root@Centos6 ~]# tmux kill-session -t bbb
[root@Centos6 ~]# tmux ls
aaa: 2 windows (created Wed Aug 30 16:54:33 2017) [112x22]
```  
 
6）重命名会话

```shell
[root@Centos6 ~]# tmux ls  
wangshibo: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)
[root@Centos6 ~]# tmux rename -t wangshibo kevin
[root@Centos6 ~]# tmux ls
kevin: 1 windows (created Sun Sep 30 10:17:00 2018) [136x29] (attached)
```

**4. 参考文献**
* https://zhuanlan.zhihu.com/p/155662601



## git的使用

**1. 介绍Git**

git是世界上最先进的分布式版本控制系统。

举个例子，如果曾用Microsoft word写文章，可能会有如下经历：想对当前文章进行修改，但又不确定是否应该修改，只能修改后另存为一个文件。而这样的次数多了， 就会出现很多个类似的文件。而过了一段时间，想找到某种特定修改情况下的文件，还得打开每个文件来寻找，十分复杂。而且会存下来很多相似但有不同的文件，使得文件管理十分混乱。如果还有其他人想要共同修改文件，那就会使得情况更加复杂。

如果有一个系统，能够自动记录每次文件的改动，还可以让其他人也同时进行编辑，而不需要自己手动管理储存一系列类似的改动的文件，也不需要在很多人之间传文件，那就会变得很方便。如果想查看之前的版本，只需要在文件改动栏里看一眼就行，这就会十分方便。

这样的系统就叫版本控制系统，而git是其中做的最好的。

Linus在发明了Linux之后，全世界的程序员都在对Linux进行贡献，而之前Linus是手动合并这些代码的。但到了后来过于繁杂，但Linus并不喜欢CVS，SVN这种集中式的版本控制系统，所以选择了BitKeeper。而之后BitKeeper不再免费提供使用，于是Linus本人用C写了一个分布式版本控制系统，就是git。

>集中式和分布式版本控制系统的区别
>集中式版本控制系统，其版本库是存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后再在自己的电脑上进行改动。改动完毕，再将文件推送给中央服务器。
>集中式版本控制系统的最大的问题就是必须得联网才能工作，如果在局域网内还好，带宽和速度都可很快，但在互联网上，就会收到网速等因素的影响。

![1]({{ '/assets/images/GIT-1.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

>而分布式版本控制系统根本没有中央服务器，每个人的电脑都是一个完整的版本库，这样每个人修改文件的时候就不需要联网了，因为版本库就在自己的本地电脑上。既然每个人都有一个完整的版本库，那如何进行多人协作呢？比如说A在本地电脑上修改了文件file，B也在其本地电脑上修改了文件file，他们只需要将各自的修改推送给对方，就可以互相查看对方的修改了。

![2]({{ '/assets/images/GIT-2.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的代码库，如果某个代码库坏了，去其他人电脑拷贝一份就行。而集中式版本控制系统的中央服务器出现问题，那所有人就无法工作。
>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能这两台电脑并不在一个局域网内，互相访问不了，等情况。因此，分布式版本控制系统通常也有一台充当”中央服务器“的电脑，但这个服务器的作用仅仅是用来方便交换大家的修改，没有的话也不要紧，只是交换修改不方便。
>Git的优势不仅是不需要联网这么简单，Git还有很强大的分支管理器，是SVN这种集中式版本控制系统所没有的。
>CVS是最早的集中式版本控制系统，但是后来被更稳定且开源的SVN取代了。
>分布式版本控制系统除了Git和BitKeeper以外，还有Mercurial和Bazaar，但Git仍然是最流行最好用的。


**2. 安装Git**

最早Git是在Linux上开发的，很长一段时间，Git也只能在Linux上运行。但现在Git已经可以在Linux、Mac和Windows上正常运行了。

**2.1 在Linux上安装Git**

先输入git，看看系统有没有安装Git：

```shell
$ git
The program 'git' is currently not installed. You can install it by calling:
sudo apt-get install git
```

如果是Debian和Ubuntu系统，直接使用：

```shell
sudo apt-get install git
```

对于其他linux版本，则直接从Git官网下载源码，解压后使用源码安装。

**2.2 在MacOS上安装Git**

Xcode已经集成了Git，不需要额外安装、


**2.3 在Windows上安装Git**

在Windows上安装Git，直接在Git官网下载安装程序，然后默认选项安装即可。

安装完成后，在菜单找到Git -> Git Bash，会有类似于命令行窗口的界面，说明安装完成。

![3]({{ '/assets/images/GIT-3.jpg' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

在安装完成后，还需设置，在命令行输入：

```shell
$ git config --global user.name "Your name"
$ git config --global user.mail "email@example.com"
```

因为Git是分布式版本控制系统，所以每个机器都需要有标签：名字和Email地址。

注意上述git config命令里用了--global参数，使用这个参数表明这台机器上所有的Git仓库都会使用这个名字和Email。当然也可以对某个仓库指定不同的用户名和Email地址。


**3. 创建版本库**

版本库又名仓库，repository，可以简单理解为一个目录，这个目录里所有的文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时候都可以追踪历史版本，或者在将来某个时刻还原历史版本。

创建一个版本库非常简单。首先，选择一个合适的地方，打开git bash，创建一个空目录：

```shell
$ mkdir learngit
$ cd learngit
$ pwd             # pwd命令用于显示当前目录
```

第二步，通过git init命令把这个目录变成Git可以管理的仓库：

```shell
$ git init
Initialized empty Git repository in /Users/Alan/learngit/.git/
```

上述/Users/Alan/learngit/是仓库的位置，名字取决于本地电脑。

上述操作就将仓库建好了，而且告诉用户是一个空的仓库，empty Git repository。之后就可以发现，目录下会多一个.git文件夹，这个文件夹是Git来跟踪管理版本库的，所以不要轻易手动修改这个目录下的文件。

而如果不可见这个.git目录，那是因为这个目录是默认隐层的，使用ls -ah命令就可以看见。

除了在空目录下创建Git仓库，也可以在已有文件的目录下创建Git仓库。

**3.1 将文件添加到版本库**

所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等，Git也不例外。版本控制系统可以告诉用户每次的改动，比如在某文件第几行添加了什么单词等。而图片、视频这种二进制文件，虽然也能由版本控制系统管理，但无法跟踪文件的变化，只能知道图片从100kb改成120kb这种信息，但不知道具体改动了什么。

Microsoft word的格式是二进制文件，所以版本控制系统是无法跟踪word文件的改动的。所以如果要真正使用版本控制系统，就要以纯文本的方式编写文件。

>文本文件和二进制文件的区别：
>识别算法把字节码0到255分为三大类：
>（1）白名单：文本型字节码，包括9(TAB)、10(LF)、32(SPACE)到255
>（2）灰名单：可容忍的字节码，包括7(BEL)、8(BS)、11(VT)、12(FF)、26(SUB)和27(ESC)
>（3）黑名单：不能容忍的、非文本型字节码，包括0(NULL)到6，14到31
>如果文件至少有一个字节属于白名单，且没有字节属于黑名单，则文件被认为是纯文本的，否则就是二进制文件。文件为空，自动识别为二进制文件。

文本文件是有编码的，建议使用标准的UTF-8编码。

>如果使用Windows自带的记事本编辑文本文件，会在每个文件开头加上0xefbbbf的字符，会导致一些不可预见的错误，所以建议使用visual studio code来替代记事本编辑文本文件。

举个例子，编写一个readme.txt文件（两行），内容如下：

```shell
Git is a version control system
Git is free software
```

其需要放在之前创建的learngit目录或者子目录下，因为这样才能被Git找到。

将文件放到Git仓库只需要两步：

第一步，在git bash里用命令git add告诉Git，将文件添加到仓库：

```shell
$ git add readme.txt
```

执行上面的命令，没有任何显示（因为Unix哲学就是没有显示说明正确）。

第二步，在git bash里用命令git commit告诉Git，将文件提交到仓库：

```shell
$ git commit -m "wrote a readme file"
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
```

git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，但最好是有意义的，这样就可以从历史记录里方便的找到改动记录。

如果不想添加任何说明，使用git commit -m是不行的，系统还是会让你输入说明，可以使用下面的方法避免输入说明：

```shell
$ git commit -a --allow-empty-message -m ""
```

git commit命令执行成功之后会显示，1 file changed：一个文件被改动（新添加的readme.txt文件），2 insertions：插入两行内容，因为创建的txt文件有两行。

而为什么Git添加文件需要add和commit两步呢？因为commit可以一次添加很多文件，所以可以多次add不同的文件，比如：

```shell
$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files"
```

**4. 回溯**

我们已经成功添加并提交了一个readme.txt文件，现在继续工作，修改readme.txt文件。改为：

```shell
Git is a distributed version control system
Git is free software
```

现在，在git bash里运行git status查看结果：

```shell
$ git status
On branch master
Changes not staged for commit:
    (use "git add <file>..." to update with what will be committed)
    (use "git checkout -- <file>..." to discard changes in working directory)


     modified:    readme.txt


no changes added to commit (use "git add" and/or "git commit -a")
```

git status可以让我们时刻掌握仓库当前的状态，上面的命令的输出告诉我们，readme.txt被修改了，但还没有准备提交。

虽然Git告诉我们readme.txt被修改了，但如果还想查看具体修改了什么内容就更好。需要用git diff这个命令来查看：

```shell
$ git diff readme.txt
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system
+Git is a distributed version control system
 Git is free software
```

git diff就是查看文件前后的difference，显示的格式是Unix通用的diff格式。可以从上面的输出看到，在第一行添加啦一个distributed单词。

在知道了readme.txt作了什么修改之后，就可以将其提交到仓库中去了。提交修改和提交新文件是一样的两个步骤，第一步是先git add：

```shell
$ git add readme.txt
```

同样没有任何输出。在执行第二步git commit之前，再运行git status看看当前仓库的状态：

```shell
$ git status
On branch master
Changes to be commited:
    (use "git reset HEAD <file>..." to unstage)
    
     modified:    readme.txt
```

git status的输出告诉我们，将要被提交的修改包括readme.txt，下一步就可以放心提交了：

```shell
$ git commit -m "add distributed"
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
```

提交后，再用git status命令查看仓库当前状态：

```shell
$ git status
On branch master
nothing to commit, working tree clean
```

Git告诉我们当前没有需要提交的修改，而且，工作目录是干净的（working tree clean）。


**4.1 版本回退**

现在我们已经知道了如何修改文件，并将修改后的文件提交到Git版本库。现在我们再修改一次readme.txt，改成如下内容：

```shell
Git is a distributed version control system
Git is a free software under the GPL
```

然后提交：

```shell
$ git add readme.txt
$ git commit -m "append GPL"
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
```

像上述操作这样，不断对文件进行修改，然后不断提交到版本库里，就像玩RPG游戏，每通过一关就会自动将游戏状态存盘，如果某一关没过去，还可以选择读取前一关的状态。有些时候，还可以手动存盘，以便失败的时候从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以保存一个快照，这个快照再Git中被称为commit。一旦把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是将之前的工作全部丢失。

readme.txt文件已经有三个版本被提交到Git仓库里了：

版本1：wrote a readme file

```shell
Git is a version control system
Git is free software
```

版本2：add distributed

```shell
Git is a distributed version control system
Git is free software
```

版本3：append GPL

```shell
Git is a distributed version control system
Git is free software distributed under the GPL
```

在实际工作里，记住几千行的代码每次都修改了什么内容是不现实的，而版本系统就是帮助我们记住这些修改的内容。版本系统里有命令可以告诉我们历史记录，在Git里，使用git log命令查看：

```shell
$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)
Author: Alan Turing <mail@example.com>
Date: Fri May 18 21:06:15 2018 +0800


    append GPL
    
commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Alan Turing <mail@example.com>
Date: Fri May 18 21:03:36 2018 +0800


    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Alan Turing <mail@example.com>
Date: Fri May 18 20:59:18 2018 +0800


    wrote a readme file
```

git log命令显示从最近到最远的提交日志。我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。

如果嫌输出信息太多，可以加上--pretty=oneline参数：

```shell
$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
```

上述一大串字符，比如1094adb7b9b3807259d8cb349e7df1d4d6477073，这是commit id（版本号）。和SVN不一样，Git的commit id不是1，2，3这种递增的数字，而是一个SHA1计算出来的很大的数字，用十六进制表示。为什么commit id需要使用这种方式呢？因为其是分布式的版本控制系统，如果有多人在一个版本库里工作，大家都用1，2，3来命名，就会起冲突。

每提交一个版本，Git就会把它们自动串成一条时间线。如果使用可视化工作查看Git历史，就可以更清楚地看到提交历史的时间线：

![4]({{ '/assets/images/GIT-4.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

现在我们将readme.txt回退到上一个版本，也就是add distributed的版本，应该怎么做呢？

首先，Git必须知道当前版本是哪个版本，在Git中用HEAD表示当前版本，也就是最新提交的1094adb7b9b3807259d8cb349e7df1d4d6477073，上一个版本就是HEAD^，上上个就是HEAD^^，以此类推。而往前100个版本不能重复100个^，所以写成HEAD~100。

现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：

```shell
$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
```

现在查看readme.txt的内容是不是版本add distributed（注意，我的电脑是Mac的，所以使用cat命令查看，Windows没有，需要使用别的方法）

```shell
$ cat readme.txt
Git is a distributed version control system
Git is free software
```

用git log来看看现在版本库的状态：

```shell
$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -> master)
Author: Alan Turing <mail@example.com>
Date: Fri May 18 21:03:36 2018 +0800


    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Alan Turing <mail@example.com>
Date: Fri May 18 20:59:18 2018 +0800


    wrote a readme file
```

最新的那个版本append GPL已经看不到了。

注意，现在我们的原来的readme.txt已经回到了上一个版本，也就是说里面的内容并没有append GPL这些句子了，也就是说真实的文件随之改变了。

如果想要再找到这个append GPL版本，只要目前的git bash窗口还没关闭，就可以找到那个append GPL版本对应的commit id，从而指定回到某个版本：

```shell
$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
```

注意到上述代码里，我们并没有完整打出append GPLde commit id，只是给了前几位，因为Git会自动去找。但如果给的太少，他可能会找到好几个版本，就无法确定是哪一个了。

我们现在再来看readme.txt的内容：

```shell
$ cat readme.txt
Git is a distributed version control system
Git is free software distributed under the GPL
```

Git的回退速度非常快，因为在Git内部有个指向当前版本的HEAD指针，当回退版本的之后，Git仅仅是把HEAD从指向append GPL改到指向add distributed。然后顺便将工作区的文件更新。所以HEAD指向哪个版本号，就会将当前版本定位在哪。

而如果现在回退到了某个版本，关掉了git bash，但之后又想回到新版本怎么办呢？因为回到某个版本就需要该版本的commit id。

Git提供了一个命令，git reflog来记录每一次git bash里的命令：

```shell
$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -> master) HEAD@{2}: commit append GPL
e475afc HEAD@{3}: commit: add distributed
eaaaf4e HEAD@{4}: commit: (initial): wrote a readme file
```

从而可以获知append GPL的commit id的前几位是1094adb，就可以使用git reset回到那个版本了。

**4.2 工作区和暂存区**

Git和其它版本控制系统如SVN的一个不同之处就在于有暂存区的概念。

*工作区（working directory）*

就是在本地电脑里能看到的目录，比如learngit文件夹就是一个工作区。

*版本库（repository）*

工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git自动创建的第一个分支master，以及指向master的一个指针HEAD。

![5]({{ '/assets/images/GIT-5.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

前面所述，将文件往Git版本库里添加的时候，是分两步进行的：

第一步是用git add把文件添进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交修改，实际上就是把暂存区的所有内容提交到当前分支。

因为我们创建Git版本库的时候，Git自动为我们创建了唯一一个master分支，所以现在git commit就是往master分支上提交更改。

从而上述过程可以理解为，需要提交的文件修改都放在暂存区，然后一次性提交暂存区所有的修改。

我们对readme.txt加上一行内容：

```shell
Git is a distributed version control system
Git is free software distributed under the GPL
Git has a mutable index called stage
```

然后，在工作区新增一个LICENSE文本文件（内容随意）

先用git status查看一下状态：

```shell
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	LICENSE

no changes added to commit (use "git add" and/or "git commit -a")
```

Git告诉我们，readme.txt被修改了，而LICENSE从未被添加过，所以状态是untracked的。

现在，使用两次命令git add，把readme.txt和LICENSE都添加之后，用git status再看一下：

```shell
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   LICENSE
	modified:   readme.txt
```

现在，暂存区的状态就变成如下的样子了：

![6]({{ '/assets/images/GIT-6.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

所以，git add命令实际上就是把要提交的所有修改放到暂存区（stage），然后，执行git commit就可以一次性将暂存区所有的修改都提交到分支。

```shell
$ git commit -m "understand how stage works"
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
```

一旦提交后，如果没有再对工作区做什么修改，那么工作区就是干净的：

```shell
$ git status
On branch master
nothing to commit, working tree clean
```

现在版本库变成了这样，暂存区就没有任何内容了：

![7]({{ '/assets/images/GIT-7.PNG' | relative_url }})
{: style="width: 800px; max-width: 100%;"}

**4.3 管理修改

为什么Git比其它版本控制系统设计的更加优秀呢？因为Git跟踪并管理的是修改，而不是文件。

什么是修改？比如新增了一行，这是修改，删除了一行，也这是修改，更改了某些字符，也是修改。甚至创建了一个新文件，这也是修改。

首先，我们对readme.txt做一个修改，比如加一行内容：

```shell
$ cat readme.txt
Git is a distributed version control system
Git is free software distributed under the GPL
Git has a mutable index called stage
Git tracks changes
```

然后，将文件添加到暂存区：

```shell
$ git add readme.txt
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
      modified:   readme.txt
```

然后，再修改readme.txt：

```shell
$ cat readme.txt
Git is a distributed version control system
Git is free software distributed under the GPL
Git has a mutable index called stage
Git tracks changes of files
```

提交：

```shell
$ git commit -m "git tracks changes"
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
```

提交后，再查看状态：

```shell
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

会发现，并不是之前在commit之后工作区就clean的状态，而是还有没提交的修改。

因为我们上述操作是：第一次修改 -> git add -> 第二次修改 -> git commit

Git管理的是修改，使用git add之后，第一次修改被放入暂存区，准备提交，但是工作区的第二次修改并没有被放暂存区，git commit只负责将暂存区的修改提交到仓库，也就是第一次修改提交，第二次修改没提交。

可以用git diff HEAD --readme.txt来查看工作区和版本库里最新版本的区别：

```shell
$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
```

可以看出第二次修改确实没有被提交。

**4.4 撤销修改

假设我们在readme.txt里又添加了一行：

```shell
$ cat readme.txt
Git is a distributed version control system
Git is free software distributed under the GPL
Git has a mutable index called stage
Git tracks changes of files
My stupid boss still prefers SVN
```

在准备使用git add提交之前，发现想要删除最后一行，那直接删除就可以了，因为其还在工作区。用git status查看一下：

```shell
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

可以发现，Git说，git checkout --file可以丢弃工作区的修改：
 
```shell
$ git checkout -- readme.txt
```

命令git checkout -- readme.txt的意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：

一种是readme.txt自修改之后还没有放到暂存区，现在，撤销修改就回到和版本库一模一样的状态
第二种是readme.txt已经添加到了暂存区，又做了修改，现在，撤销修改就是回到添加到暂存区之后的状态

总之，就是让文件回到最近一次git commit或者git add时的状态。

在做了git checkout -- readme.txt操作之后的readme.txt文件就是：

```shell
$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
```

果然回到了之前。

注意，git checkout -- file里的--很重要，如果没有的话，就变成了切换到另一个分支的命令。

如果，我们在工作区修改了文件，还git add到了暂存区了：

```shell
$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

$ git add readme.txt
```

但是还没有执行git commit。用git status查看，修应只是放到了暂存区，还没有提交：

```shell
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   readme.txt
```

Git同样告诉我们，使用命令git reset HEAD file就可以把暂存区的修改撤销掉（unstage），重新放回工作区：

```shell
$ git reset HEAD readme.txt
Unstaged changed after reset:
M    readme.txt
```

git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们使用HEAD时候，表示最新的版本。

再用git status查看，可以发现现在暂存区是干净的，工作区有修改：

```shell
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt
```

再使用git checkout -- file来丢弃工作区的修改：

```shell
$ git chekcout -- readme.txt

$ git status
On branch master
nothing to commit, working tree clear
```

假设，现在在工作区修改了文件，用git add添加到了暂存区，还用git commit推送到了版本库，就可以使用之前的版本回退那一节的方法，回退到之前的版本。不过如果已经将本地的版本库推送到远程，那就覆水难收了。

**4.5 删除文件

在Git中，删除也是一个修改操作。

我们先添加一个test.txt到Git并提交：

```shell
$ git add test.txt

$ git commit -m "add test.txt"
[master b84166e] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
```

在本地工作区，如果要删除文件，直接删了，或者用rm命令删了：

```shell
$ rm test.py
```

这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会告诉你哪些文件被删除了：

```shell
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	deleted:    test.txt

no changes added to commit (use "git add" and/or "git commit -a")
```

现在有两个选择，一是确实要从版本库里删除该文件，那就使用git rm删除，并且git commit：

```shell
$ git rm test.txt
rm 'test.txt'

$ git commit -m "remove test.txt"
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
```

现在，文件就从版本库中被删除了。

另一种情况是本地工作区删错了，因为版本库里还有这个文件，所以可以轻松的将文件恢复到最新版本：

```shell
$ git checkout -- test.txt
```

git checkout实际上是用版本库里的版本替换掉工作区的版本，无论工作区是修改还是删除，都可以一键还原。



